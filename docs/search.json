[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mathematics of Data",
    "section": "",
    "text": "ðŸ“˜ Unit 1: Data, Vectors, and Matrices\nCopyright: Â© 2025 Jason R. Wilson. All rights reserved.\nThis book is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).\nLicense: CC BY 4.0\nWelcome to Mathematics of Data â€” a modern, computational introduction.\nEach chapter includes Python-based demonstrations and interactive exercises, designed to support both understanding and exploration.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#unit-1-data-vectors-and-matrices",
    "href": "index.html#unit-1-data-vectors-and-matrices",
    "title": "Mathematics of Data",
    "section": "",
    "text": "Chapter 1: Data and Vectors",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "chapter1/data_vectors.html",
    "href": "chapter1/data_vectors.html",
    "title": "Chapter 1: Data and Vectors",
    "section": "",
    "text": "Palmer Penguins\nIn this section, we begin by exploring the Palmer penguin dataset, which contains measurements from several species of penguins collected in Antarctica.\nThe Palmer penguin dataset contains characteristics or features for penguins representing three species â€” Adelie, Gentoo, and Chinstrap â€” collected from three islands in the Palmer Archipelago, Antarctica. It includes multiple physical measurements for each penguin, such as:\n\nFlipper length (mm)\n\nBill length (mm)\n\nBill depth (mm)\n\nBody mass (g)\n\nThe above measurements are called numerical features. The dataset also includes non-numerical features such as \"species\" and \"island\" that we call categorical features.\nTogether, these features â€” both numerical and categorical â€” describe each individual penguin in the dataset. They allow us to compare penguins, detect patterns, and make predictions.\nTo start working with the penguin dataset in table form, we will use the Python package pandas, which is widely used in data science.\nIn pandas, a dataset is stored as a data frame â€” a table of data where:\n\nEach row of the data frame contains the features for a particular penguin.\n\nEach column of the data frame contains the values of a particular feature â€” such as flipper length or body mass â€” across all penguins.\n\nHere is some code that loads in the dataset as the data frame penguins_raw and prints out the number of penguins, the number of features, and the name of each feature:\n\n\nCode\nimport pandas as pd\n\n# Load the dataset from Seaborn's GitHub repository\nurl = \"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv\"\npenguins_raw = pd.read_csv(url)\n\n# Print number of samples (rows) and features (columns)\nrows, cols = penguins_raw.shape\nprint(\"Number of penguins:\", rows)\nprint(\"Number of features:\", cols)\nprint(\"All features in the dataset:\")\nprint(list(penguins_raw.columns))\n\n\nNumber of penguins: 344\nNumber of features: 7\nAll features in the dataset:\n['species', 'island', 'bill_length_mm', 'bill_depth_mm', 'flipper_length_mm', 'body_mass_g', 'sex']\n\n\n\nCleaning and Filtering Data\nReal-world data is often messy. In this case, some rows are missing values â€” for example, a penguin might have been weighed but not measured. To keep things simple for now, weâ€™ll remove any rows that contain missing values and put the result in the new data frame penguins_clean.\n\n\nCode\npenguins_clean = penguins_raw.dropna()\nprint(\"Number of penguins (after data cleaning):\",len(penguins_clean))\n\n\nNumber of penguins (after data cleaning): 333\n\n\nFor now we will focus on five features that describe the shape and size of each penguin and its species:\n\nBill length\nBill depth\nFlipper length\nBody mass\nSpecies\n\nWeâ€™ll store these features in a new data frame called penguins and print the first few rows to get a sense of what weâ€™re working with.\n\n\nCode\n# Keep only the features we want to focus on\nfeature_columns = [\"bill_length_mm\", \"bill_depth_mm\", \"flipper_length_mm\", \"body_mass_g\", \"species\"]\npenguins = penguins_clean[feature_columns]\n\n# Print the first few rows our dataset\nprint(penguins.head())\n\n\n   bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g species\n0            39.1           18.7              181.0       3750.0  Adelie\n1            39.5           17.4              186.0       3800.0  Adelie\n2            40.3           18.0              195.0       3250.0  Adelie\n4            36.7           19.3              193.0       3450.0  Adelie\n5            39.3           20.6              190.0       3650.0  Adelie\n\n\n\n\n\n\n\n\nIndexing in Python\n\n\n\nPython uses 0-based indexing, which means counting starts at 0, not 1.\nFor example, the first penguin in the table has index \\(0\\), the second penguin has index \\(1\\), and so on.\n\n\n\n\nAccessing Table Entries\nSingle entries of the pandas data frame penguins give us the value of a specific feature for one of the penguins.\nTo access a single entry in the table:\n\nSelect the feature (e.g., \"flipper_length_mm\")\n\nSelect the penguin by its index (starting from 0)\n\nFor example, the code below prints the flipper length of the first penguin.\n\n\nCode\nflipper_length_0 = penguins[\"flipper_length_mm\"].iloc[0]\nprint(\"Flipper length of the first penguin:\", flipper_length_0, \"mm\")\n\n\nFlipper length of the first penguin: 181.0 mm\n\n\nHereâ€™s a breakdown of what penguins[\"flipper_length_mm\"].iloc[0] means:\n\npenguins[\"flipper_length_mm\"] gives us the entire column of flipper lengths. In pandas, this column is called a Series â€” a one-dimensional object with one value per penguin.\n.iloc[0] selects the first entry in that Series â€” in this case, the flipper length of the first penguin.\n\nNow that we know how to access individual entries in the dataset, letâ€™s compute an average.\n\nExercise: Compute the average bill depth of the first 3 penguins in the dataset. Use round(..., 1) to round the average to one decimal place.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\nWeâ€™ll extract the first three values from the \"bill_depth_mm\" column, then compute their average:\n\n\nCode\nd0 = penguins[\"bill_depth_mm\"].iloc[0]\nd1 = penguins[\"bill_depth_mm\"].iloc[1]\nd2 = penguins[\"bill_depth_mm\"].iloc[2]\n\naverage_depth = round((d0 + d1 + d2) / 3, 1)\nprint(\"Average bill depth of first 3 penguins:\", average_depth, \"mm\")\n\n\nAverage bill depth of first 3 penguins: 18.0 mm\n\n\n\n\n\n\n\n\nSummary Statistics\nSo far weâ€™ve worked with individual entries in a data frame â€” like the bill depth of the first penguin.\nSometimes we want to compute across an entire feature. For example, to find the average body mass across all penguins, we need the body mass for every penguin â€” not just one.\n\nNumerical Features\nWe can use built-in pandas methods like .mean(), .median(), .std(), .min(), and .max() to compute summary statistics for a single feature stored as a pandas series.\n\n\nCode\nbody_mass = penguins[\"body_mass_g\"]\nprint(\"Average body mass:\", round(body_mass.mean(), 1), \"g\")\nprint(\"Standard deviation of body mass:\", round(body_mass.std(), 1), \"g\")\nprint(\"Median body mass:\", body_mass.median(), \"g\")\nprint(\"Minimum body mass:\", body_mass.min(), \"g\")\nprint(\"Maximum body mass:\", body_mass.max(), \"g\")\n\n\nAverage body mass: 4207.1 g\nStandard deviation of body mass: 805.2 g\nMedian body mass: 4050.0 g\nMinimum body mass: 2700.0 g\nMaximum body mass: 6300.0 g\n\n\n\nExercise: Print the average, median, standard deviation, minimum, and maximum of the bill length feature.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\n\nCode\nbill_length = penguins[\"bill_length_mm\"]\nprint(\"Average bill length:\", round(bill_length.mean(), 1), \"mm\")\nprint(\"Median bill length:\", bill_length.median(), \"mm\")\nprint(\"Standard deviation of bill length:\", round(bill_length.std(), 1), \"mm\")\nprint(\"Minimum bill length:\", bill_length.min(), \"mm\")\nprint(\"Maximum bill length:\", bill_length.max(), \"mm\")\n\n\nAverage bill length: 44.0 mm\nMedian bill length: 44.5 mm\nStandard deviation of bill length: 5.5 mm\nMinimum bill length: 32.1 mm\nMaximum bill length: 59.6 mm\n\n\n\n\n\nIn addition to functions like .max() and .min(), which return the largest or smallest value in a pandas series, there are also functions that tell us where those values occur.\nFor example: - .idxmax() returns the row of the maximum value in a series. - .idxmin() returns the row of the minimum value in a series.\nThese are useful when we want to identify, for example, which penguin has the longest bill or the shortest flippers.\n\n\nCode\n# Find the row of the penguin with the longest bill\nlongest_bill_row = penguins[\"bill_length_mm\"].idxmax()\nprint(\"Row of penguin with longest bill:\", longest_bill_row)\n\n\nRow of penguin with longest bill: 253\n\n\nWe can then extract the full row â€” that is, all features for that penguin:\n\n\nCode\nlongest_bill_features = penguins.loc[longest_bill_row]\nprint(\"Features of the penguin with the longest bill:\")\nprint(longest_bill_features)\n\n\nFeatures of the penguin with the longest bill:\nbill_length_mm         59.6\nbill_depth_mm          17.0\nflipper_length_mm     230.0\nbody_mass_g          6050.0\nspecies              Gentoo\nName: 253, dtype: object\n\n\n\nExercise: Find the penguin with the shortest flippers. Then extract and print the full row of features for that penguin.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\n\nCode\n# Find the row of the penguin with the shortest flippers\nshortest_flippers_row = penguins[\"flipper_length_mm\"].idxmin()\nprint(\"Row of penguin with shortest flippers:\",shortest_flippers_row)\n\n# Extract and print the row\nshortest_flippers_features = penguins.loc[shortest_flippers_row]\nprint(\"Features of the penguin with the shortest flippers:\")\nprint(shortest_flippers_features)\n\n\nRow of penguin with shortest flippers: 28\nFeatures of the penguin with the shortest flippers:\nbill_length_mm         37.9\nbill_depth_mm          18.6\nflipper_length_mm     172.0\nbody_mass_g          3150.0\nspecies              Adelie\nName: 28, dtype: object\n\n\n\n\n\n\n\nCategorical Features\nSo far weâ€™ve focused on numerical features like flipper length and body mass. But not all features are numbers â€” some describe categories like species or island.\nTo summarize a categorical feature, we often want to count how many times each category appears. The .value_counts() function does exactly that.\nFor example, to count the number of penguins in each species:\n\n\nCode\nspecies_counts = penguins[\"species\"].value_counts()\nprint(\"Number of penguins in each species:\")\nprint(species_counts)\n\n\nNumber of penguins in each species:\nspecies\nAdelie       146\nGentoo       119\nChinstrap     68\nName: count, dtype: int64\n\n\n\nExercise: How many penguins are there from each island? How many of each sex are there? Note: To complete this exercise, you will need to use the penguins_clean data frame, which contains all of the original features.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\n\nCode\n# Count by island\nisland_counts = penguins_clean[\"island\"].value_counts()\nprint(\"Number of penguins from each island:\")\nprint(island_counts)\n\n# Add a newline\nprint()\n\n# Count by sex\nsex_counts = penguins_clean[\"sex\"].value_counts()\nprint(\"Number of penguins of each sex:\")\nprint(sex_counts)\n\n\nNumber of penguins from each island:\nisland\nBiscoe       163\nDream        123\nTorgersen     47\nName: count, dtype: int64\n\nNumber of penguins of each sex:\nsex\nMALE      168\nFEMALE    165\nName: count, dtype: int64\n\n\n\n\n\n\n\n\nVisualization\nSo far weâ€™ve used summary statistics like .mean() and .std() to describe each feature. But sometimes itâ€™s easier to understand the structure of a dataset by looking at it.\nIn this section, we use plots to explore the distribution of individual features and to see how those features vary across species.\n\nHistograms and Box Plots\nLetâ€™s start by visualizing a single numerical feature: flipper length.\nThis histogram shows how flipper length is distributed across all penguins in the dataset.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(7, 5))\n\nsns.histplot(data=penguins, x=\"flipper_length_mm\", bins=20, color=\"slateblue\", edgecolor=\"black\")\nplt.title(\"Histogram of Flipper Length\")\nplt.xlabel(\"Flipper Length (mm)\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n\n\n\n\n\n\nThis plot shows the overall shape of the data â€” but it doesnâ€™t tell us how flipper length varies by species.\nNow letâ€™s improve the plot by color-coding the data by species and overlaying the histograms. This helps us see how much the species overlap in flipper length.\n\n\nCode\nplt.figure(figsize=(7, 5))\n\nsns.histplot(\n    data=penguins,\n    x=\"flipper_length_mm\",\n    hue=\"species\",\n    bins=20,\n    multiple=\"layer\",\n    palette=\"Set1\",\n    edgecolor=\"black\",\n    alpha=0.6\n)\n\nplt.title(\"Histogram of Flipper Length by Species\")\nplt.xlabel(\"Flipper Length (mm)\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n\n\n\n\n\n\nFrom this version of the plot, we can see that:\n\nGentoo penguins tend to have the longest flippers.\nAdelie and Chinstrap penguins are more similar, with a lot of overlap.\n\nThis suggests that flipper length can help distinguish species â€” especially Gentoo â€” but itâ€™s not enough to fully separate the data on its own.\nNext, weâ€™ll use box plots for each of the four numerical features to compare the distributions more precisely across species. This will help us see whether any single feature fully separates the data.\n\n\nCode\nplt.figure(figsize=(7, 6))\n\n# Define the list of numerical features\nfeatures = [\"bill_length_mm\", \"bill_depth_mm\", \"flipper_length_mm\", \"body_mass_g\"]\n\n# Create a 2x2 grid of box plots\nfor i, feature in enumerate(features):\n    plt.subplot(2, 2, i + 1)\n    sns.boxplot(data=penguins, x=\"species\", y=feature, hue=\"species\", palette=\"Set2\", legend=False)\n    plt.title(f\"{feature.replace('_', ' ').title()}\")\n    plt.xlabel(\"Species\")\n    plt.ylabel(None)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThe box plots show that some features â€” like flipper length â€” are better than others at distinguishing species, and that no feature fully separates the data on its own.\n\n\nScatter Plots and Clustering\nPreviously, we saw that no single feature â€” like flipper length or bill depth â€” is enough to fully separate the three penguin species. But what happens when we look at two features at once?\nBy using a scatter plot where each axis represents a different feature, we can see how penguins cluster in two-dimensional space, and whether certain combinations of features help distinguish the species more clearly.\nThe scatter plots below show three such combinations:\n\nFlipper length vs.Â Bill length\n\nFlipper length vs.Â Bill depth\n\nBill length vs.Â Bill depth\n\nEach point represents a penguin and its color indicates the species.\n\n\nCode\n# Define the feature pairs\nfeature_pairs = [\n    (\"flipper_length_mm\", \"bill_length_mm\"),\n    (\"flipper_length_mm\", \"bill_depth_mm\"),\n    (\"bill_length_mm\", \"bill_depth_mm\")\n]\n\n# Set up a 3-row, 1-column layout\nfig, axes = plt.subplots(3, 1, figsize=(7, 15))\n\n# Loop through the feature pairs\nfor ax, (x_feature, y_feature) in zip(axes, feature_pairs):\n    sns.scatterplot(\n        data=penguins,\n        x=x_feature,\n        y=y_feature,\n        hue=\"species\",\n        palette=\"Set1\",\n        edgecolor=\"black\",\n        alpha=0.75,\n        s=60,\n        ax=ax\n    )\n    ax.set_xlabel(x_feature.replace('_', ' ').title())\n    ax.set_ylabel(y_feature.replace('_', ' ').title())\n    ax.set_title(f\"{x_feature.replace('_', ' ').title()} vs {y_feature.replace('_', ' ').title()}\")\n    ax.legend(title=\"Species\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThese scatter plots show that two of the three feature pairs result in clear species separation into clusters.\nA cluster is a group of data points that are close together in a plot and share similar characteristics. In this context, each cluster tends to contain penguins from the same species.\nIf two species form well-separated clusters in a scatter plot, it means those two species are easy to distinguish using just those two features.\n\nExercise: Using scatter plots, compare body mass against each of: flipper length, bill length, and bill depth. Which pair(s) give a clean separation of the data into species clusters? Do any pair of features look like they are linearly related?\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\nAs we see below, only bill length vs body mass results in a strong visual separation between the species.\nAlso, flipper length and body mass appear to be linearly related â€”â€“ the points fall roughly along a straight line. As flipper length increases, body mass increases in a steady, consistent way.\n\n\n\nCode\n# Define the feature pairs\nfeature_pairs = [\n    (\"flipper_length_mm\",\"body_mass_g\"),\n    (\"bill_length_mm\",\"body_mass_g\"),\n    (\"bill_depth_mm\",\"body_mass_g\")\n]\n\n# Set up a 3-row, 1-column layout\nfig, axes = plt.subplots(3, 1, figsize=(7, 15))\n\n# Loop through the feature pairs\nfor ax, (x_feature, y_feature) in zip(axes, feature_pairs):\n    sns.scatterplot(\n        data=penguins,\n        x=x_feature,\n        y=y_feature,\n        hue=\"species\",\n        palette=\"Set1\",\n        edgecolor=\"black\",\n        alpha=0.75,\n        s=60,\n        ax=ax\n    )\n    ax.set_xlabel(x_feature.replace('_', ' ').title())\n    ax.set_ylabel(y_feature.replace('_', ' ').title())\n    ax.set_title(f\"{x_feature.replace('_', ' ').title()} vs {y_feature.replace('_', ' ').title()}\")\n    ax.legend(title=\"Species\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive 3D Scatter Plots\nWe can visualize all five features at the same time by using:\n\n3D position for: flipper length, bill length, and bill depth\n\nPoint size to represent: body mass\n\nPoint color to indicate: species\n\nThis interactive plot lets you explore the full structure of the data:\n\nUse your mouse to zoom, rotate, and pan the view.\nHover over points to see the values for individual penguins.\nTry to find a viewpoint where the species clusters are most clearly separated.\n\n\n\nCode\nimport plotly.express as px\n\n# Shift and rescale body mass to use it as a point size\nbody_mass = penguins[\"body_mass_g\"]\npenguins_new = penguins.copy()\npenguins_new[\"body_mass_scaled\"] = round((body_mass - 2700) / 100, 1) + 1\n\n# Create a 3D scatter plot using 4 features\nfig = px.scatter_3d(\n    penguins_new,\n    x=\"flipper_length_mm\",\n    y=\"bill_length_mm\",\n    z=\"bill_depth_mm\",\n    color=\"species\",\n    size=\"body_mass_scaled\",\n    title=\"Scatter Plot in 3D with Body Mass as Point Size\",\n    labels={\n        \"flipper_length_mm\": \"Flipper Length (mm)\",\n        \"bill_length_mm\": \"Bill Length (mm)\",\n        \"bill_depth_mm\": \"Bill Depth (mm)\",\n        \"body_mass_scaled\": \"Body Mass (scaled)\"\n    }\n)\n\nfig.show()\n\n\n                                                \n\n\n\n\n\nPrediction and Vectors\nLetâ€™s again consider a scatter plot of flipper length vs.Â body mass.\n\n\nCode\n# Create the scatter plot with a single color\nplt.figure(figsize=(7, 5))\nsns.scatterplot(\n    data=penguins,\n    x=\"flipper_length_mm\",\n    y=\"body_mass_g\",\n    color=\"steelblue\",       # Single color\n    edgecolor=\"black\",\n    alpha=0.7\n)\n\nplt.title(\"Body Mass vs. Flipper Length\")\nplt.xlabel(\"Flipper Length (mm)\")\nplt.ylabel(\"Body Mass (g)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThese two features appear to be linearly related â€”â€“ the points fall roughly along a straight line. As flipper length increases, body mass increases in a steady, consistent way.\nThis suggests that body mass could be roughly predicted from flipper length.\nIn order to make predictions, we need to first fit a line to the data.\nA straight line has the general form:\n\\[\ny = \\beta x + v\n\\]\nwhere:\n\n\\(x\\) is the input feature (in this case, flipper length),\n\\(y\\) is the predicted output (in this case, body mass),\n\\(\\beta\\) is the slope of the line,\n\\(v\\) is the intercept â€” the value of \\(y\\) when \\(x = 0\\).\n\nFor this feature pair, letâ€™s try using the line:\n\\[\ny = 49.7 x - 5780.8\n\\]\nLetâ€™s first see how well the line fits the data visually:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Known slope and intercept\nbeta = 49.7\nv = -5780.8\n\n# Define the x range using min and max of the actual data\nx = penguins[\"flipper_length_mm\"]\ny = penguins[\"body_mass_g\"]\n\nx0 = x.min()\nx1 = x.max()\ny0 = beta * x0 + v\ny1 = beta * x1 + v\n\n# Create scatter plot and add the line using two points\nplt.figure(figsize=(7, 5))\nsns.scatterplot(x=x, y=y, color=\"steelblue\", edgecolor=\"black\", alpha=0.7)\nplt.plot([x0, x1], [y0, y1], color=\"red\", linewidth=2, label=f\"y = {beta}x + {v}\")\nplt.xlabel(\"Flipper Length (mm)\")\nplt.ylabel(\"Body Mass (g)\")\nplt.title(\"Modeling Body Mass as a Linear Function of Flipper Length\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nRemaining Topics\nThis final part of Chapter 1 builds toward the least squares derivation for fitting a line using the math of vectors, orthogonality, and projections.\n\nPose the Central Questions\n\nHow do we measure how well a line fits the data?\nGiven a way to measure fit, how do we find the best line?\n\nBoth questions require us to understand and operate on vectors.\nIntroduce Vectors Formally\n\nDefine a vector as a list of numbers â€” one per penguin.\nDefine basic vector operations:\n\nScalar multiplication\nVector addition\nLinear combinations\n\nExpress the predicted body mass vector as the linear combination:\n\n\\[\n\\mathbf{\\hat{y}} = \\beta \\mathbf{x} + v \\mathbf{1}\n\\]\n\nShow how to compute this feature in Python using broadcasting (without NumPy).\n\nMeasuring Fit Using Vector Distance\n\nDefine the error vector: \\(\\mathbf{e} = \\mathbf{y} - \\mathbf{\\hat{y}}\\) -Define:\n\nVector length (norm),\nDifference vectors, and\nDistance between vectors using squared error\n\nThis gives us a numerical measure of how good the fit is.\n\nThe Goal: Least Squares Line\n\nDefine the least squares line as the one that minimizes the squared error between predicted and actual body mass.\nEmphasize: weâ€™re looking for \\(\\beta\\) and \\(v\\) that minimize:\n\n\\[\n\\|\\mathbf{y} - (\\beta \\mathbf{x} + v)\\|^2\n\\]\nGeometric Insight\n\nDraw a cartoon in \\(\\mathbb{R}^2\\) (or \\(\\mathbb{R}^{333}\\) abstractly).\n\nShow:\n\nActual feature vector \\(\\mathbf{y}\\)\nApproximate vector \\(\\hat{\\mathbf{y}}\\) (not lying on line in the \\(\\mathbf{y}\\) direction)\nError vector \\(\\mathbf{e}\\)\n\n\nArgue: To minimize error, \\(\\mathbf{e}\\) must be orthogonal to the line in the direction of \\(\\mathbf{y}\\).\n\nOrthogonality and the Dot Product\n\nRecall the Pythagorean theorem and use it to motivate the dot product .. vectors are orthogonal if and only if \\(x_1 y_1 + ...+ x_n y_n = 0\\)\nDefine the dot product:\n\n\\[\n\\mathbf{x}^T \\mathbf{y} = x_1 y_1 + \\cdots + x_n y_n\n\\]\n\nDefine orthogonality via dot product\n\n\\[\n\\mathbf{x} \\perp \\mathbf{e} \\iff \\mathbf{x}^T \\mathbf{e} = 0\n\\]\nProjection Onto a Line\n\nDefine the orthogonal projection of \\(\\mathbf{y}\\) onto the line spanned by \\(\\mathbf{x}\\)\nState the condition: the residual vector must be orthogonal to \\(\\mathbf{x}\\)\nDerive the projection formula:\n\n\\[\n\\mathbf{\\hat{y}} = \\frac{\\mathbf{x}^T \\mathbf{y}}{\\mathbf{x}^T \\mathbf{x}} \\cdot \\mathbf{x}\n\\]\nProve It Minimizes Error\n\nUse the Pythagorean theorem and triangle inequality to show:\nThis projection is the closest possible vector to \\(\\mathbf{y}\\) on the line\nConclude: this is the best possible predictor using a single feature\n\nDerive the Least Squares Line\n\nFrom projection: compute the slope \\(\\beta\\) and intercept of the least squares line.\n\nCorrelation and Linearity\n\nAsk: What makes two features linearly related?\nUse the dot product to define correlation:\n\n\\[\n\\text{corr}(\\mathbf{x}, \\mathbf{y}) = \\frac{\\mathbf{x}^T \\mathbf{y}}{\\|\\mathbf{x}\\| \\|\\mathbf{y}\\|}\n\\]\n\nInvestigate which other pairs of penquin features are strongly correlated (if any)\nPreview the deeper connection between correlation and linear prediction\n\nSummarize and preview multivariable models and matrices for chapter 2.",
    "crumbs": [
      "Unit 1: Data, Vectors, and Matrices",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Chapter 1: Data and Vectors</span>"
    ]
  }
]